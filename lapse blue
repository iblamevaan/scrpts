-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")

-- Player
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- SETTINGS
local BALL_COUNT = 1
local ORBIT_RADIUS = 35
local ORBIT_SPEED = 5
local UP_DOWN_RANGE = 10
local UP_DOWN_SPEED = 2
local BALL_SIZE = 15
local FADE_TIME = 1.5
local LIFETIME = 1.5
local PULL_RADIUS = 25
local PULL_VELOCITY = 250
local PULL_FORCE = 400000
local COOLDOWN = 1

local balls = {}
local lastUsed = 0

-- SFX function
local function sfx(id, parent, is3D)
	local sound = Instance.new("Sound")
	sound.SoundId = id:match("rbxassetid://") and id or "rbxassetid://"..id
	sound.Parent = parent
	sound.RollOffMode = Enum.RollOffMode.Linear
	sound.EmitterSize = is3D and 10 or 0
	sound.RollOffMaxDistance = is3D and 100 or 0
	sound.PlayOnRemove = false
	sound.Looped = false
	return sound
end

-- Play all SFX
local function playSFX()
	local sounds = {
		{"122261039674349",5},{"7652527370",1},{"127117086239111",2},
		{"76786040776528",3},{"8737379396",0.5},{"3276835551",1},
		{"0",4},{"7390331288",2}
	}
	for _, data in ipairs(sounds) do
		local sound = sfx(data[1], Workspace, true)
		sound.Volume = data[2]
		task.spawn(function() sound:Play() end)
	end
end

-- Get nearby unanchored parts (original Region3 method)
local function getNearbyUnanchoredParts(centerPos, range)
	local region = Region3.new(centerPos - Vector3.new(range, range, range), centerPos + Vector3.new(range, range, range))
	local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, {player.Character}, math.huge)
	local valid = {}
	for _, part in ipairs(parts) do
		if part:IsA("BasePart") and not part.Anchored and not part:IsDescendantOf(player.Character) then
			table.insert(valid, part)
		end
	end
	return valid
end

-- Create glowing ball
local function createBall()
	local part = Instance.new("Part")
	part.Shape = Enum.PartType.Ball
	part.Size = Vector3.new(BALL_SIZE, BALL_SIZE, BALL_SIZE)
	part.Material = Enum.Material.Neon
	part.Color = Color3.fromRGB(0,162,255)
	part.Anchored = true
	part.CanCollide = false
	part.Parent = Workspace

	local light = Instance.new("PointLight")
	light.Color = part.Color
	light.Brightness = 2
	light.Range = 8
	light.Parent = part

	return part, light
end

-- Spawn balls and trigger pull
local function spawnBalls()
	playSFX()
	for i=1,BALL_COUNT do
		local part, light = createBall()
		local ball = {
			part = part,
			light = light,
			angle = math.random()*math.pi*2,
			heightOffset = math.random()*math.pi*2,
			baseOrbitSpeed = ORBIT_SPEED,
			baseVerticalSpeed = UP_DOWN_SPEED,
			fadeStartTime = nil
		}
		table.insert(balls, ball)
		task.delay(LIFETIME, function()
			ball.fadeStartTime = tick()
		end)
	end
end

-- Pull parts (original working logic)
local function pullParts(center)
	local nearbyParts = getNearbyUnanchoredParts(center, PULL_RADIUS)
	for _, target in ipairs(nearbyParts) do
		local direction = (center - target.Position)
		if direction.Magnitude == 0 then continue end
		local bv = Instance.new("BodyVelocity")
		bv.Velocity = direction.Unit * PULL_VELOCITY
		bv.MaxForce = Vector3.new(PULL_FORCE,PULL_FORCE,PULL_FORCE)
		bv.P = PULL_FORCE
		bv.Name = "PullForce"
		bv.Parent = target
		Debris:AddItem(bv, 0.1)
	end
end

-- Update loop
RunService.RenderStepped:Connect(function(dt)
	for i=#balls,1,-1 do
		local ball = balls[i]
		local part = ball.part
		if not part or not part.Parent then table.remove(balls,i) continue end

		-- Fade
		local alpha = 0
		if ball.fadeStartTime then
			alpha = math.clamp((tick() - ball.fadeStartTime)/FADE_TIME,0,1)
			part.Transparency = alpha
			ball.light.Brightness = 2*(1-alpha)
			if alpha >= 1 then
				part:Destroy()
				table.remove(balls,i)
				continue
			end
		end

		-- Orbit
		local fadeMult = 1-alpha
		ball.angle += ball.baseOrbitSpeed * fadeMult * dt
		ball.heightOffset += ball.baseVerticalSpeed * fadeMult * dt
		local pos = root.Position + Vector3.new(
			math.cos(ball.angle)*ORBIT_RADIUS,
			math.sin(ball.heightOffset)*UP_DOWN_RANGE + 3,
			math.sin(ball.angle)*ORBIT_RADIUS
		)
		part.Position = pos

		-- Pull parts
		pullParts(pos)
	end
end)

-- Bind Z key with cooldown
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.Z and tick()-lastUsed >= COOLDOWN then
		lastUsed = tick()
		spawnBalls()
	end
end)
